# 🚀 VS Code + PlatformIO Arduino Nano ESP32 완전 가이드

## 📋 목표: VS Code + PlatformIO 환경에서 드론 개발을 위한 ESP32 구축

**개발 환경**: Windows + VS Code + PlatformIO + Arduino Framework

---

## 1️⃣ 개발 환경 구축 (45분)

### **1.1 VS Code 설치**

#### **VS Code 다운로드 및 설치**
```
1. 공식 사이트 방문: https://code.visualstudio.com/
2. "Download for Windows" 클릭
3. 설치 파일 실행
4. 설치 옵션:
   ✅ Add "Open with Code" action to Windows Explorer file context menu
   ✅ Add "Open with Code" action to Windows Explorer directory context menu
   ✅ Register Code as an editor for supported file types
   ✅ Add to PATH (requires shell restart)
5. 설치 완료 후 VS Code 실행
```

### **1.2 PlatformIO IDE 확장 설치**

#### **PlatformIO 설치 과정**
```
1. VS Code 실행
2. 왼쪽 사이드바의 Extensions 아이콘 클릭 (Ctrl+Shift+X)
3. 검색창에 "PlatformIO IDE" 입력
4. "PlatformIO IDE" by PlatformIO 선택
5. "Install" 버튼 클릭
6. 설치 완료 후 VS Code 재시작
7. 하단 상태표시줄에 PlatformIO 아이콘 확인
```

#### **PlatformIO 초기 설정**
```
재시작 후:
1. 왼쪽 사이드바에 PlatformIO 아이콘 (개미 모양) 생성 확인
2. PlatformIO 아이콘 클릭
3. "PlatformIO Home" 탭이 열리면 성공!
4. 첫 실행 시 추가 도구 설치 진행 (5-10분 소요)
```

### **1.3 Arduino Framework 설정**

#### **플랫폼 및 보드 설정**
PlatformIO는 자동으로 ESP32 플랫폼을 관리합니다.
프로젝트 생성 시 자동으로 다운로드됩니다.

---

## 2️⃣ 첫 번째 프로젝트 생성

### **2.1 새 프로젝트 생성**

#### **프로젝트 생성 과정**
```
1. VS Code에서 PlatformIO 아이콘 클릭
2. "Home" → "New Project" 클릭
3. 프로젝트 설정:
   - Name: "ESP32_LED_Test"
   - Board: "Arduino Nano ESP32" 검색 후 선택
   - Framework: "Arduino" 선택
   - Location: 기본값 사용 (또는 원하는 폴더 선택)
4. "Finish" 클릭
5. 프로젝트 초기화 완료 대기 (3-5분)
```

#### **프로젝트 구조 확인**
```
ESP32_LED_Test/
├── .pio/                 # PlatformIO 빌드 파일
├── .vscode/              # VS Code 설정
├── include/              # 헤더 파일
├── lib/                  # 사용자 라이브러리
├── src/                  # 메인 소스 코드
│   └── main.cpp         # 메인 파일 (Arduino의 .ino 파일과 동일)
├── test/                # 테스트 코드
└── platformio.ini       # 프로젝트 설정 파일
```

### **2.2 platformio.ini 설정**

#### **기본 설정 파일 수정**
```
; PlatformIO Project Configuration File

[env:arduino_nano_esp32]
platform = espressif32
board = arduino_nano_esp32
framework = arduino

; 시리얼 모니터 설정
monitor_speed = 115200
monitor_port = AUTO

; 업로드 설정
upload_speed = 921600

; 빌드 플래그 (필요시)
build_flags = 
    -DCORE_DEBUG_LEVEL=3
    -DARDUINO_USB_CDC_ON_BOOT=1

; 라이브러리 의존성
lib_deps = 
    hideakitai/MPU9250@^0.4.7
    madhephaestus/ESP32Servo@^0.13.0
    bblanchon/ArduinoJson@^6.21.3
    esphome/AsyncTCP-esphome@^2.0.1
    lacamera/ESPAsyncWebServer@^2.2.1
    br3ttb/PID@^1.2.1
```

---

## 3️⃣ 하드웨어 연결 및 기본 테스트

### **3.1 첫 번째 테스트: LED 점멸**

#### **하드웨어 연결**
```
준비물:
• Arduino Nano ESP32
• USB-C 케이블
• 브레드보드
• LED 1개
• 220Ω 저항 1개
• 점퍼 와이어

연결 방법:
1. Arduino Nano ESP32를 브레드보드에 삽입
2. D2 핀 → 220Ω 저항 → LED 긴 다리 (애노드)
3. LED 짧은 다리 (캐소드) → GND
```

#### **코드 작성 (src/main.cpp)**
```
/*
 * Arduino Nano ESP32 LED 점멸 테스트 (수정된 버전)
 * 환경: VS Code + PlatformIO
 * 목적: 기본 하드웨어 동작 확인
 */

#include <Arduino.h>  // PlatformIO에서는 필수!

// 핀 정의
const int LED_PIN = 2;

// 전역 변수
unsigned long previousMillis = 0;
const long interval = 1000;  // 1초 간격
bool ledState = false;

void setup() {
    // 시리얼 통신 초기화
    Serial.begin(115200);
    
    // 시리얼 포트 준비 대기
    while (!Serial && millis() < 5000) {
        delay(10);
    }
    
    // LED 핀 설정
    pinMode(LED_PIN, OUTPUT);
    digitalWrite(LED_PIN, LOW);
    
    // 시작 메시지
    Serial.println("====================================");
    Serial.println("Arduino Nano ESP32 LED 테스트 시작");
    Serial.println("PlatformIO 환경에서 실행");
    Serial.println("====================================");
    
    // 시스템 정보 출력
    Serial.printf("칩 모델: %s\n", ESP.getChipModel());
    Serial.printf("칩 리비전: %d\n", ESP.getChipRevision());
    Serial.printf("CPU 주파수: %d MHz\n", getCpuFrequencyMhz());
    Serial.printf("Flash 크기: %d MB\n", ESP.getFlashChipSize() / 1024 / 1024);
    Serial.printf("여유 메모리: %d bytes\n", ESP.getFreeHeap());
    Serial.println();
}

void loop() {
    unsigned long currentMillis = millis();
    
    // 비차단 LED 제어 (millis() 사용)
    if (currentMillis - previousMillis >= interval) {
        previousMillis = currentMillis;
        
        // LED 상태 토글
        ledState = !ledState;
        digitalWrite(LED_PIN, ledState);
        
        // 상태 출력
        Serial.printf("[%lu ms] LED %s\n", 
                     currentMillis, 
                     ledState ? "ON" : "OFF");
        
        // 메모리 사용량 주기적 출력 (10초마다)
        static int counter = 0;
        if (++counter >= 10) {
            counter = 0;
            Serial.printf("현재 여유 메모리: %d bytes\n", ESP.getFreeHeap());
        }
    }
    
    // 다른 작업을 위한 여유 시간
    yield();
}
```

#### **빌드 및 업로드**
```
1. Arduino Nano ESP32를 USB-C로 PC에 연결
2. VS Code 하단 상태표시줄에서:
   - 환경 확인: "arduino_nano_esp32" 표시
   - 포트 확인: COM 포트 자동 감지
3. 빌드: Ctrl+Alt+B (또는 하단 ✓ 아이콘)
4. 업로드: Ctrl+Alt+U (또는 하단 → 아이콘)
5. 시리얼 모니터: Ctrl+Alt+S (또는 하단 🔌 아이콘)
```

#### **예상 결과**
```
시리얼 모니터 출력:
====================================
Arduino Nano ESP32 LED 테스트 시작
PlatformIO 환경에서 실행
====================================
칩 모델: ESP32-S3
칩 리비전: 0
CPU 주파수: 240 MHz
Flash 크기: 16 MB
여유 메모리: 327680 bytes

[1000 ms] LED ON
[2000 ms] LED OFF
[3000 ms] LED ON
...
```

---

### **3.2 두 번째 테스트: WiFi 연결**

#### **새 프로젝트 생성**
```
프로젝트명: "ESP32_WiFi_Test"
동일한 설정으로 프로젝트 생성
```

#### **코드 작성 (src/main.cpp)**
```cpp
/*
 * Arduino Nano ESP32 WiFi 연결 테스트
 * 환경: VS Code + PlatformIO
 */

#include <Arduino.h>
#include <WiFi.h>

// WiFi 설정 (본인의 정보로 변경!)
const char* WIFI_SSID = "YOUR_WIFI_NAME";
const char* WIFI_PASSWORD = "YOUR_WIFI_PASSWORD";

// 연결 타임아웃 (밀리초)
const unsigned long WIFI_TIMEOUT = 20000;

void setup() {
    Serial.begin(115200);
    while (!Serial && millis() < 5000) delay(10);
    
    Serial.println("\n====================================");
    Serial.println("Arduino Nano ESP32 WiFi 테스트");
    Serial.println("PlatformIO 환경에서 실행");
    Serial.println("====================================");
    
    // WiFi 모듈 정보
    Serial.printf("WiFi MAC 주소: %s\n", WiFi.macAddress().c_str());
    
    // WiFi 연결 시작
    Serial.printf("WiFi 연결 시도: %s\n", WIFI_SSID);
    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
    
    // 연결 대기
    unsigned long startTime = millis();
    Serial.print("연결 중");
    
    while (WiFi.status() != WL_CONNECTED && 
           (millis() - startTime) < WIFI_TIMEOUT) {
        delay(500);
        Serial.print(".");
    }
    
    Serial.println();
    
    // 연결 결과 확인
    if (WiFi.status() == WL_CONNECTED) {
        Serial.println("✅ WiFi 연결 성공!");
        printWiFiInfo();
    } else {
        Serial.println("❌ WiFi 연결 실패!");
        Serial.println("설정을 확인하고 재시도하세요.");
        printWiFiStatus();
    }
}

void loop() {
    // WiFi 상태 모니터링 (10초마다)
    static unsigned long lastCheck = 0;
    if (millis() - lastCheck >= 10000) {
        lastCheck = millis();
        
        if (WiFi.status() == WL_CONNECTED) {
            Serial.printf("[%lu] WiFi 연결됨 - RSSI: %d dBm\n", 
                         millis(), WiFi.RSSI());
        } else {
            Serial.printf("[%lu] WiFi 연결 끊어짐 - 재연결 시도\n", millis());
            WiFi.reconnect();
        }
    }
    
    yield();
}

void printWiFiInfo() {
    Serial.println("--- WiFi 연결 정보 ---");
    Serial.printf("SSID: %s\n", WiFi.SSID().c_str());
    Serial.printf("IP 주소: %s\n", WiFi.localIP().toString().c_str());
    Serial.printf("서브넷 마스크: %s\n", WiFi.subnetMask().toString().c_str());
    Serial.printf("게이트웨이: %s\n", WiFi.gatewayIP().toString().c_str());
    Serial.printf("DNS: %s\n", WiFi.dnsIP().toString().c_str());
    Serial.printf("신호 강도: %d dBm\n", WiFi.RSSI());
    Serial.printf("채널: %d\n", WiFi.channel());
    Serial.println("------------------------");
}

void printWiFiStatus() {
    Serial.print("WiFi 상태: ");
    switch (WiFi.status()) {
        case WL_IDLE_STATUS:
            Serial.println("대기 중");
            break;
        case WL_NO_SSID_AVAIL:
            Serial.println("SSID를 찾을 수 없음");
            break;
        case WL_SCAN_COMPLETED:
            Serial.println("스캔 완료");
            break;
        case WL_CONNECTED:
            Serial.println("연결됨");
            break;
        case WL_CONNECT_FAILED:
            Serial.println("연결 실패");
            break;
        case WL_CONNECTION_LOST:
            Serial.println("연결 끊어짐");
            break;
        case WL_DISCONNECTED:
            Serial.println("연결 해제됨");
            break;
        default:
            Serial.println("알 수 없는 상태");
            break;
    }
}
```

---

### **3.3 세 번째 테스트: 전력 소비 및 성능 측정**
### ESP32_PowerAndPerformance_Test
#### **고급 모니터링 코드**
```
/*
 * Arduino Nano ESP32 전력 및 성능 테스트
 * 환경: VS Code + PlatformIO
 */

#include <Arduino.h>
#include <WiFi.h>
#include <driver/adc.h>

// 테스트 설정
const int TEST_DURATION = 30000;  // 각 테스트 30초
const int SAMPLE_INTERVAL = 1000; // 1초마다 샘플링

// 성능 카운터
struct PerformanceCounter {
    unsigned long loops;
    unsigned long maxLoopTime;
    unsigned long minLoopTime;
    unsigned long totalLoopTime;
};

PerformanceCounter perfCounter = {0, 0, ULONG_MAX, 0};

void setup() {
    Serial.begin(115200);
    while (!Serial && millis() < 5000) delay(10);
    
    Serial.println("\n====================================");
    Serial.println("Arduino Nano ESP32 전력/성능 테스트");
    Serial.println("====================================");
    
    // 시스템 정보
    printSystemInfo();
    
    // 테스트 시퀀스 실행
    testNormalOperation();
    testWiFiOperation();
    testLightSleepMode();
    
    Serial.println("모든 테스트 완료!");
}

void loop() {
    // 성능 측정을 위한 루프
    unsigned long loopStart = micros();
    
    // 간단한 작업 시뮬레이션
    for (int i = 0; i < 100; i++) {
        float dummy = sin(i * 0.1) + cos(i * 0.1);
        (void)dummy; // 컴파일러 경고 방지
    }
    
    unsigned long loopTime = micros() - loopStart;
    updatePerformanceCounter(loopTime);
    
    // 1초마다 성능 리포트
    static unsigned long lastReport = 0;
    if (millis() - lastReport >= 1000) {
        lastReport = millis();
        printPerformanceReport();
    }
    
    yield();
}

void printSystemInfo() {
    Serial.println("--- 시스템 정보 ---");
    Serial.printf("칩: %s Rev %d\n", ESP.getChipModel(), ESP.getChipRevision());
    Serial.printf("코어 수: %d\n", ESP.getChipCores());
    Serial.printf("CPU 주파수: %d MHz\n", getCpuFrequencyMhz());
    Serial.printf("Flash: %d MB (%d MHz)\n", 
                 ESP.getFlashChipSize() / 1024 / 1024,
                 ESP.getFlashChipSpeed() / 1000000);
    Serial.printf("PSRAM: %d bytes\n", ESP.getPsramSize());
    Serial.printf("여유 메모리: %d bytes\n", ESP.getFreeHeap());
    Serial.printf("최대 할당 가능: %d bytes\n", ESP.getMaxAllocHeap());
    Serial.printf("내부 온도: %.1f°C\n", temperatureRead());
    Serial.println("--------------------\n");
}

void testNormalOperation() {
    Serial.println("📊 일반 동작 모드 테스트 시작");
    Serial.println("멀티미터로 전류를 측정하세요 (예상: 80-120mA)");
    
    unsigned long startTime = millis();
    unsigned long nextSample = startTime;
    
    while (millis() - startTime < TEST_DURATION) {
        // CPU 부하 생성
        for (int i = 0; i < 1000; i++) {
            float calculation = sqrt(i) * sin(i * 0.01);
            (void)calculation;
        }
        
        // 샘플링
        if (millis() >= nextSample) {
            Serial.printf("메모리: %d bytes, 온도: %.1f°C\n", 
                         ESP.getFreeHeap(), temperatureRead());
            nextSample += SAMPLE_INTERVAL;
        }
        
        yield();
    }
    
    Serial.println("✅ 일반 동작 테스트 완료\n");
}

void testWiFiOperation() {
    Serial.println("📊 WiFi 활성 모드 테스트 시작");
    Serial.println("예상 전류: 120-200mA");
    
    WiFi.begin("TestNetwork", "password"); // 가상 네트워크
    
    unsigned long startTime = millis();
    unsigned long nextSample = startTime;
    
    while (millis() - startTime < TEST_DURATION) {
        // WiFi 스캔 활동 유지
        if (millis() % 5000 == 0) {
            WiFi.scanNetworks(true); // 비동기 스캔
        }
        
        // 샘플링
        if (millis() >= nextSample) {
            Serial.printf("WiFi 상태: %d, 메모리: %d bytes\n", 
                         WiFi.status(), ESP.getFreeHeap());
            nextSample += SAMPLE_INTERVAL;
        }
        
        yield();
    }
    
    WiFi.disconnect();
    Serial.println("✅ WiFi 모드 테스트 완료\n");
}

void testLightSleepMode() {
    Serial.println("📊 Light Sleep 모드 테스트 시작");
    Serial.println("예상 전류: 1-5mA");
    Serial.println("5초 후 절전모드 진입 (10초간)");
    
    delay(5000);
    Serial.println("절전모드 진입...");
    Serial.flush(); // 시리얼 버퍼 비우기
    
    // Light Sleep 설정
    esp_sleep_enable_timer_wakeup(10 * 1000000); // 10초
    esp_light_sleep_start();
    
    Serial.println("절전모드에서 깨어남!");
    Serial.println("✅ Light Sleep 테스트 완료\n");
}

void updatePerformanceCounter(unsigned long loopTime) {
    perfCounter.loops++;
    perfCounter.totalLoopTime += loopTime;
    
    if (loopTime > perfCounter.maxLoopTime) {
        perfCounter.maxLoopTime = loopTime;
    }
    
    if (loopTime < perfCounter.minLoopTime) {
        perfCounter.minLoopTime = loopTime;
    }
}

void printPerformanceReport() {
    if (perfCounter.loops > 0) {
        unsigned long avgLoopTime = perfCounter.totalLoopTime / perfCounter.loops;
        
        Serial.printf("성능: 평균 %lu μs, 최대 %lu μs, 최소 %lu μs, 총 %lu 루프\n",
                     avgLoopTime, perfCounter.maxLoopTime, 
                     perfCounter.minLoopTime, perfCounter.loops);
        
        // 카운터 리셋
        perfCounter = {0, 0, ULONG_MAX, 0};
    }
}
```

---

## 4️⃣ PlatformIO 고급 기능 활용

### **4.1 시리얼 플로터 사용**

#### **데이터 시각화 코드**
```cpp
/*
 * 시리얼 플로터용 데이터 출력
 * VS Code: Ctrl+Alt+S → Serial Plotter 탭 선택
 */

#include <Arduino.h>

void setup() {
    Serial.begin(115200);
    Serial.println("시간,CPU온도,메모리사용률,가상센서값");
}

void loop() {
    float temperature = temperatureRead();
    float memoryUsage = (float)(ESP.getHeapSize() - ESP.getFreeHeap()) / ESP.getHeapSize() * 100;
    float virtualSensor = 50 + 20 * sin(millis() * 0.001); // 가상 센서 데이터
    
    // CSV 형태로 출력 (플로터에서 그래프로 표시)
    Serial.printf("%.1f,%.1f,%.1f\n", temperature, memoryUsage, virtualSensor);
    
    delay(100);
}
```

### **4.2 라이브러리 관리**

#### **platformio.ini 고급 설정**
```ini
[env:arduino_nano_esp32]
platform = espressif32
board = arduino_nano_esp32
framework = arduino

; 모니터 설정
monitor_speed = 115200
monitor_filters = esp32_exception_decoder

; 빌드 설정
build_type = debug
build_flags = 
    -DCORE_DEBUG_LEVEL=4
    -DARDUINO_USB_CDC_ON_BOOT=1
    -DBOARD_HAS_PSRAM
    -mfix-esp32-psram-cache-issue

; 라이브러리
lib_deps = 
    hideakitai/MPU9250@^0.4.7
    madhephaestus/ESP32Servo@^0.13.0
    bblanchon/ArduinoJson@^6.21.3
    esphome/AsyncTCP-esphome@^2.0.1
    lacamera/ESPAsyncWebServer@^2.2.1
    br3ttb/PID@^1.2.1

; 업로드 설정
upload_speed = 921600
upload_port = AUTO

; 디버그 설정 (선택사항)
debug_tool = esp-prog
debug_init_break = tbreak setup
```

### **4.3 태스크 정의**

#### **.vscode/tasks.json 생성**
```json
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "PIO Build",
            "type": "shell",
            "command": "platformio",
            "args": ["run"],
            "group": "build",
            "presentation": {
                "reveal": "always",
                "panel": "new"
            },
            "problemMatcher": "$gcc"
        },
        {
            "label": "PIO Upload",
            "type": "shell", 
            "command": "platformio",
            "args": ["run", "--target", "upload"],
            "group": "build"
        },
        {
            "label": "PIO Monitor",
            "type": "shell",
            "command": "platformio", 
            "args": ["device", "monitor"],
            "group": "build"
        }
    ]
}
```

---

## 5️⃣ 문제 해결 및 디버깅

### **5.1 일반적인 문제들**

#### **빌드 오류**
```bash
# 캐시 클리어
pio run --target clean

# 플랫폼 업데이트
pio platform update espressif32

# 라이브러리 재설치
pio lib uninstall [라이브러리명]
pio lib install [라이브러리명]
```

#### **업로드 실패**
```bash
# 포트 확인
pio device list

# 수동 포트 지정 (platformio.ini)
upload_port = COM3  ; Windows
; upload_port = /dev/ttyUSB0  ; Linux
```

### **5.2 고급 디버깅**

#### **메모리 누수 감지 코드**
```cpp
#include <Arduino.h>

class MemoryTracker {
private:
    size_t initialFreeHeap;
    
public:
    MemoryTracker() {
        initialFreeHeap = ESP.getFreeHeap();
    }
    
    void checkpoint(const char* label) {
        size_t currentFree = ESP.getFreeHeap();
        int diff = (int)currentFree - (int)initialFreeHeap;
        
        Serial.printf("[%s] 메모리: %d bytes (변화: %+d bytes)\n", 
                     label, currentFree, diff);
        
        if (diff < -1000) {  // 1KB 이상 감소시 경고
            Serial.println("⚠️  메모리 누수 가능성 감지!");
        }
    }
};

// 사용 예제
MemoryTracker memTracker;

void setup() {
    Serial.begin(115200);
    memTracker.checkpoint("시작");
    
    // 초기화 코드...
    memTracker.checkpoint("초기화 후");
}

void loop() {
    // 주기적으로 메모리 확인
    static unsigned long lastCheck = 0;
    if (millis() - lastCheck >= 10000) {
        lastCheck = millis();
        memTracker.checkpoint("10초 후");
    }
}
```

---

# 🚀 드론 개발 프로젝트 템플릿 및 다음 단계 가이드

## 📋 현재 상황: MPU9250 자세 추정 시스템 완료
**다음 목표**: PID 제어 시스템 + 모터 제어 개발

---

## 6️⃣ 다음 단계 준비

### **6.1 완성된 드론 프로젝트 템플릿 생성**

#### **새 프로젝트 생성: "ESP32_Drone_Controller_v1"**

**PlatformIO 프로젝트 설정:**
```ini
; platformio.ini - 완전한 드론 컨트롤러 설정
[env:arduino_nano_esp32_drone]
platform = espressif32
board = arduino_nano_esp32
framework = arduino

; 시리얼 및 모니터링
monitor_speed = 115200
monitor_filters = esp32_exception_decoder, time
upload_speed = 921600

; 최적화 빌드 플래그
build_flags = 
    -DCORE_DEBUG_LEVEL=2
    -DARDUINO_USB_CDC_ON_BOOT=1
    -DCONFIG_FREERTOS_HZ=1000
    -DBOARD_HAS_PSRAM
    -Os                    ; 크기 최적화
    -ffast-math           ; 수학 연산 최적화
    -DMPU9250_SPI=0       ; I2C 사용

; 드론 전용 라이브러리 의존성
lib_deps = 
    ; 센서 라이브러리
    hideakitai/MPU9250@^0.4.7
    
    ; 모터 제어
    madhephaestus/ESP32Servo@^0.13.0
    
    ; 통신 라이브러리
    bblanchon/ArduinoJson@^6.21.3
    esphome/AsyncTCP-esphome@^2.0.1
    lacamera/ESPAsyncWebServer@^2.2.1
    
    ; 제어 시스템
    br3ttb/PID@^1.2.1
    
    ; 유틸리티
    paulstoffregen/Time@^1.6.1
    knolleary/PubSubClient@^2.8

; 디버그 환경 (개발용)
[env:debug]
extends = env:arduino_nano_esp32_drone
build_type = debug
build_flags = 
    ${env:arduino_nano_esp32_drone.build_flags}
    -DCORE_DEBUG_LEVEL=4
    -DDEBUG_DRONE=1
    -DSERIAL_DEBUG=1
```

#### **완전한 프로젝트 구조**
```
ESP32_Drone_Controller_v1/
├── .vscode/
│   ├── settings.json          # VS Code 워크스페이스 설정
│   ├── tasks.json            # 빌드 태스크 정의
│   ├── launch.json           # 디버깅 설정
│   └── extensions.json       # 추천 확장 프로그램
├── include/
│   ├── config.h              # 전역 설정값
│   ├── pins.h                # 핀 매핑 정의
│   ├── sensors/
│   │   ├── imu_sensor.h      # IMU 센서 인터페이스
│   │   └── sensor_fusion.h   # 센서 융합 알고리즘
│   ├── control/
│   │   ├── pid_controller.h  # PID 컨트롤러
│   │   ├── flight_modes.h    # 비행 모드 정의
│   │   └── motor_mixer.h     # 모터 믹싱 알고리즘
│   ├── communication/
│   │   ├── receiver.h        # 수신기 인터페이스
│   │   ├── telemetry.h       # 텔레메트리 시스템
│   │   └── web_interface.h   # 웹 인터페이스
│   └── safety/
│       ├── failsafe.h        # 안전 시스템
│       └── battery_monitor.h # 배터리 모니터링
├── src/
│   ├── main.cpp              # 메인 엔트리 포인트
│   ├── sensors/
│   │   ├── imu_sensor.cpp
│   │   └── sensor_fusion.cpp
│   ├── control/
│   │   ├── pid_controller.cpp
│   │   ├── flight_modes.cpp
│   │   └── motor_mixer.cpp
│   ├── communication/
│   │   ├── receiver.cpp
│   │   ├── telemetry.cpp
│   │   └── web_interface.cpp
│   └── safety/
│       ├── failsafe.cpp
│       └── battery_monitor.cpp
├── lib/
│   └── DroneCore/            # 사용자 정의 드론 코어 라이브러리
│       ├── DroneCore.h
│       └── DroneCore.cpp
├── test/
│   ├── test_sensors/         # 센서 단위 테스트
│   ├── test_control/         # 제어 시스템 테스트
│   └── test_integration/     # 통합 테스트
├── data/                     # 웹 인터페이스 파일
│   ├── index.html
│   ├── style.css
│   └── app.js
├── docs/
│   ├── README.md
│   ├── CALIBRATION.md
│   ├── TUNING.md
│   └── API.md
└── platformio.ini
```

### **6.2 핵심 헤더 파일 구성**

#### **config.h - 전역 설정**
```cpp
#ifndef CONFIG_H
#define CONFIG_H

// 프로젝트 정보
#define DRONE_NAME "ESP32 Quadcopter v1.0"
#define FIRMWARE_VERSION "1.0.0"
#define BUILD_DATE __DATE__ " " __TIME__

// 하드웨어 설정
#define USE_MPU9250         1
#define USE_BAROMETER       0
#define USE_GPS             0
#define USE_OPTICAL_FLOW    0

// 제어 주파수 설정
#define MAIN_LOOP_RATE_HZ   1000    // 메인 제어 루프
#define IMU_SAMPLE_RATE_HZ  1000    // IMU 샘플링
#define PID_RATE_HZ         500     // PID 계산 주파수
#define MOTOR_UPDATE_HZ     500     // 모터 업데이트
#define TELEMETRY_RATE_HZ   50      // 텔레메트리 전송

// 안전 설정
#define FAILSAFE_TIMEOUT_MS     1000    // 수신기 신호 타임아웃
#define LOW_BATTERY_VOLTAGE     3.3f    // 저전압 경고 (V)
#define CRITICAL_BATTERY_VOLTAGE 3.0f  // 긴급착륙 전압
#define MAX_ANGLE_LIMIT         45.0f   // 최대 기울기 제한 (도)
#define MAX_RATE_LIMIT          720.0f  // 최대 회전 속도 (도/초)

// PID 기본값 (나중에 튜닝)
#define DEFAULT_ROLL_RATE_P     0.1f
#define DEFAULT_ROLL_RATE_I     0.05f
#define DEFAULT_ROLL_RATE_D     0.01f
#define DEFAULT_PITCH_RATE_P    0.1f
#define DEFAULT_PITCH_RATE_I    0.05f
#define DEFAULT_PITCH_RATE_D    0.01f
#define DEFAULT_YAW_RATE_P      0.15f
#define DEFAULT_YAW_RATE_I      0.02f
#define DEFAULT_YAW_RATE_D      0.0f

// 디버그 설정
#ifdef DEBUG_DRONE
    #define DEBUG_PRINT(x) Serial.print(x)
    #define DEBUG_PRINTLN(x) Serial.println(x)
    #define DEBUG_PRINTF(format, ...) Serial.printf(format, ##__VA_ARGS__)
#else
    #define DEBUG_PRINT(x)
    #define DEBUG_PRINTLN(x)
    #define DEBUG_PRINTF(format, ...)
#endif

#endif // CONFIG_H
```

#### **pins.h - 핀 매핑 정의**
```cpp
#ifndef PINS_H
#define PINS_H

// I2C 핀 (MPU9250)
#define I2C_SDA_PIN             4
#define I2C_SCL_PIN             5

// 모터 출력 핀 (PWM/DShot)
#define MOTOR_1_PIN             25      // 전방 우측
#define MOTOR_2_PIN             26      // 전방 좌측
#define MOTOR_3_PIN             27      // 후방 좌측
#define MOTOR_4_PIN             14      // 후방 우측

// 수신기 입력 핀
#define RC_INPUT_PIN            16      // SBUS/PPM 입력
#define RC_RSSI_PIN             17      // RSSI 아날로그 입력

// 상태 표시 LED
#define LED_STATUS_PIN          2       // 내장 LED
#define LED_ARM_PIN             18      // ARM 상태 LED
#define LED_GPS_PIN             19      // GPS 상태 LED (미래 확장)

// 부저 핀
#define BUZZER_PIN              13      // 경고음/상태음

// 배터리 전압 모니터링
#define BATTERY_VOLTAGE_PIN     A0      // 전압 분배기 입력
#define BATTERY_CURRENT_PIN     A1      // 전류 센서 입력 (옵션)

// SPI 핀 (미래 확장용 - SD카드, 추가 센서)
#define SPI_MISO_PIN            12
#define SPI_MOSI_PIN            11
#define SPI_SCLK_PIN            10
#define SPI_CS_PIN              9

// UART 핀 (GPS, 텔레메트리)
#define UART1_TX_PIN            21      // GPS TX
#define UART1_RX_PIN            20      // GPS RX
#define UART2_TX_PIN            7       // 텔레메트리 TX
#define UART2_RX_PIN            6       // 텔레메트리 RX

// 인터럽트 핀
#define IMU_INT_PIN             3       // MPU9250 인터럽트
#define RC_INT_PIN              8       // 수신기 인터럽트 (PPM)

#endif // PINS_H
```

### **6.3 메인 시스템 아키텍처**

#### **main.cpp - 드론 메인 시스템**
```cpp
/*
 * ESP32 Drone Controller v1.0
 * 메인 시스템 - 멀티태스킹 아키텍처
 */

#include <Arduino.h>
#include <WiFi.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include <freertos/semphr.h>

// 프로젝트 헤더
#include "config.h"
#include "pins.h"
#include "sensors/imu_sensor.h"
#include "sensors/sensor_fusion.h"
#include "control/pid_controller.h"
#include "control/flight_modes.h"
#include "control/motor_mixer.h"
#include "communication/receiver.h"
#include "communication/telemetry.h"
#include "communication/web_interface.h"
#include "safety/failsafe.h"
#include "safety/battery_monitor.h"

// 전역 객체
IMUSensor imu;
SensorFusion sensorFusion;
PIDController pidController;
FlightModes flightModes;
MotorMixer motorMixer;
Receiver receiver;
Telemetry telemetry;
WebInterface webInterface;
FailsafeSystem failsafe;
BatteryMonitor batteryMonitor;

// FreeRTOS 태스크 핸들
TaskHandle_t sensorTaskHandle = NULL;
TaskHandle_t controlTaskHandle = NULL;
TaskHandle_t motorTaskHandle = NULL;
TaskHandle_t telemetryTaskHandle = NULL;
TaskHandle_t safetyTaskHandle = NULL;

// 뮤텍스 및 세마포어
SemaphoreHandle_t sensorDataMutex;
SemaphoreHandle_t controlDataMutex;

// 시스템 상태 구조체
struct SystemState {
    // 센서 데이터
    struct {
        float roll, pitch, yaw;
        float rollRate, pitchRate, yawRate;
        float accelX, accelY, accelZ;
        bool valid;
    } attitude;
    
    // 제어 데이터
    struct {
        float throttle;     // 0.0 ~ 1.0
        float rollCmd;      // -1.0 ~ 1.0
        float pitchCmd;     // -1.0 ~ 1.0
        float yawCmd;       // -1.0 ~ 1.0
        bool armed;
        uint8_t flightMode;
    } control;
    
    // 모터 출력
    struct {
        uint16_t motor1, motor2, motor3, motor4;  // 1000-2000 μs
        bool enabled;
    } motors;
    
    // 시스템 상태
    struct {
        float batteryVoltage;
        float batteryCurrent;
        bool rcConnected;
        bool imuHealthy;
        uint32_t loopCount;
        uint16_t loopFrequency;
    } system;
};

SystemState systemState = {0};

void setup() {
    Serial.begin(115200);
    while (!Serial && millis() < 5000) delay(10);
    
    printStartupBanner();
    
    // 핀 초기화
    initializePins();
    
    // 하드웨어 초기화
    if (!initializeHardware()) {
        Serial.println("❌ 하드웨어 초기화 실패!");
        while (1) {
            blinkErrorPattern();
            delay(1000);
        }
    }
    
    // FreeRTOS 동기화 객체 생성
    createSyncObjects();
    
    // 멀티태스킹 시작
    createTasks();
    
    Serial.println("✅ 드론 시스템 초기화 완료!");
    Serial.printf("📊 사용 가능 메모리: %d bytes\n", ESP.getFreeHeap());
    Serial.printf("⚡ CPU 주파수: %d MHz\n", getCpuFrequencyMhz());
    
    // 안전 체크
    performSafetyCheck();
}

void loop() {
    // 메인 루프는 시스템 모니터링만 수행
    static unsigned long lastHeartbeat = 0;
    
    if (millis() - lastHeartbeat >= 5000) {  // 5초마다
        lastHeartbeat = millis();
        printSystemStatus();
        
        // 하트비트 LED
        digitalWrite(LED_STATUS_PIN, !digitalRead(LED_STATUS_PIN));
        
        // 메모리 누수 체크
        if (ESP.getFreeHeap() < 50000) {  // 50KB 미만 시 경고
            Serial.println("⚠️  메모리 부족 경고!");
        }
    }
    
    // 시스템 안전 체크
    if (!systemState.system.imuHealthy || 
        systemState.system.batteryVoltage < LOW_BATTERY_VOLTAGE) {
        // 긴급 상황 처리
        handleEmergency();
    }
    
    delay(100);  // 메인 루프는 10Hz
}

// 센서 데이터 처리 태스크 (최고 우선순위, 코어 0)
void sensorTask(void *parameter) {
    Serial.println("📊 센서 태스크 시작 (코어 0)");
    
    TickType_t xLastWakeTime = xTaskGetTickCount();
    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / IMU_SAMPLE_RATE_HZ);
    
    uint32_t loopCounter = 0;
    unsigned long lastFreqCheck = millis();
    
    while (true) {
        // IMU 데이터 읽기
        if (imu.update()) {
            // 센서 융합 수행
            sensorFusion.update(
                imu.getAccelX(), imu.getAccelY(), imu.getAccelZ(),
                imu.getGyroX(), imu.getGyroY(), imu.getGyroZ(),
                imu.getMagX(), imu.getMagY(), imu.getMagZ()
            );
            
            // 공유 데이터 업데이트
            if (xSemaphoreTake(sensorDataMutex, pdMS_TO_TICKS(1)) == pdTRUE) {
                systemState.attitude.roll = sensorFusion.getRoll();
                systemState.attitude.pitch = sensorFusion.getPitch();
                systemState.attitude.yaw = sensorFusion.getYaw();
                
                systemState.attitude.rollRate = imu.getGyroX();
                systemState.attitude.pitchRate = imu.getGyroY();
                systemState.attitude.yawRate = imu.getGyroZ();
                
                systemState.attitude.accelX = imu.getAccelX();
                systemState.attitude.accelY = imu.getAccelY();
                systemState.attitude.accelZ = imu.getAccelZ();
                
                systemState.attitude.valid = true;
                systemState.system.imuHealthy = true;
                
                // 주파수 계산
                if (millis() - lastFreqCheck >= 1000) {
                    systemState.system.loopFrequency = loopCounter;
                    loopCounter = 0;
                    lastFreqCheck = millis();
                }
                systemState.system.loopCount = ++loopCounter;
                
                xSemaphoreGive(sensorDataMutex);
            }
        } else {
            // IMU 통신 오류
            systemState.system.imuHealthy = false;
            DEBUG_PRINTLN("⚠️  IMU 통신 오류");
        }
        
        // 정확한 타이밍 유지
        vTaskDelayUntil(&xLastWakeTime, xFrequency);
    }
}

// 비행 제어 태스크 (높은 우선순위, 코어 0)
void controlTask(void *parameter) {
    Serial.println("🎮 제어 태스크 시작 (코어 0)");
    
    TickType_t xLastWakeTime = xTaskGetTickCount();
    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / PID_RATE_HZ);
    
    while (true) {
        // 수신기 데이터 읽기
        receiver.update();
        
        // Failsafe 체크
        bool rcValid = failsafe.checkReceiver(receiver.isConnected());
        systemState.system.rcConnected = rcValid;
        
        if (rcValid && systemState.attitude.valid) {
            // 수신기 입력 가져오기
            float throttleInput = receiver.getThrottle();
            float rollInput = receiver.getRoll();
            float pitchInput = receiver.getPitch();
            float yawInput = receiver.getYaw();
            bool armSwitch = receiver.getArmSwitch();
            
            // 비행 모드 처리
            uint8_t currentMode = flightModes.update(receiver.getFlightModeSwitch());
            
            // ARM/DISARM 로직
            bool shouldArm = armSwitch && 
                           systemState.system.imuHealthy && 
                           systemState.system.batteryVoltage > LOW_BATTERY_VOLTAGE &&
                           throttleInput < 0.1f;  // 스로틀이 낮을 때만 ARM 가능
            
            // 공유 데이터에서 현재 자세 읽기
            float currentRoll, currentPitch, currentYaw;
            float currentRollRate, currentPitchRate, currentYawRate;
            
            if (xSemaphoreTake(sensorDataMutex, pdMS_TO_TICKS(1)) == pdTRUE) {
                currentRoll = systemState.attitude.roll;
                currentPitch = systemState.attitude.pitch;
                currentYaw = systemState.attitude.yaw;
                currentRollRate = systemState.attitude.rollRate;
                currentPitchRate = systemState.attitude.pitchRate;
                currentYawRate = systemState.attitude.yawRate;
                xSemaphoreGive(sensorDataMutex);
            }
            
            // PID 제어 계산
            float rollOutput = 0, pitchOutput = 0, yawOutput = 0;
            
            if (shouldArm) {
                // 비행 모드에 따른 제어
                switch (currentMode) {
                    case FLIGHT_MODE_STABILIZE:
                        // 각도 제어 모드
                        rollOutput = pidController.calculateAngleControl(
                            rollInput * MAX_ANGLE_LIMIT, currentRoll, currentRollRate
                        );
                        pitchOutput = pidController.calculateAngleControl(
                            pitchInput * MAX_ANGLE_LIMIT, currentPitch, currentPitchRate
                        );
                        yawOutput = pidController.calculateRateControl(
                            yawInput * MAX_RATE_LIMIT, currentYawRate
                        );
                        break;
                        
                    case FLIGHT_MODE_ACRO:
                        // 각속도 제어 모드
                        rollOutput = pidController.calculateRateControl(
                            rollInput * MAX_RATE_LIMIT, currentRollRate
                        );
                        pitchOutput = pidController.calculateRateControl(
                            pitchInput * MAX_RATE_LIMIT, currentPitchRate
                        );
                        yawOutput = pidController.calculateRateControl(
                            yawInput * MAX_RATE_LIMIT, currentYawRate
                        );
                        break;
                }
            }
            
            // 제어 데이터 업데이트
            if (xSemaphoreTake(controlDataMutex, pdMS_TO_TICKS(1)) == pdTRUE) {
                systemState.control.throttle = shouldArm ? throttleInput : 0.0f;
                systemState.control.rollCmd = rollOutput;
                systemState.control.pitchCmd = pitchOutput;
                systemState.control.yawCmd = yawOutput;
                systemState.control.armed = shouldArm;
                systemState.control.flightMode = currentMode;
                xSemaphoreGive(controlDataMutex);
            }
        } else {
            // RC 연결 없음 또는 센서 오류 - 안전 모드
            if (xSemaphoreTake(controlDataMutex, pdMS_TO_TICKS(1)) == pdTRUE) {
                systemState.control.throttle = 0.0f;
                systemState.control.rollCmd = 0.0f;
                systemState.control.pitchCmd = 0.0f;
                systemState.control.yawCmd = 0.0f;
                systemState.control.armed = false;
                xSemaphoreGive(controlDataMutex);
            }
        }
        
        vTaskDelayUntil(&xLastWakeTime, xFrequency);
    }
}

// 모터 출력 태스크 (높은 우선순위, 코어 1)
void motorTask(void *parameter) {
    Serial.println("⚡ 모터 태스크 시작 (코어 1)");
    
    TickType_t xLastWakeTime = xTaskGetTickCount();
    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / MOTOR_UPDATE_HZ);
    
    while (true) {
        // 제어 명령 읽기
        float throttle, rollCmd, pitchCmd, yawCmd;
        bool armed;
        
        if (xSemaphoreTake(controlDataMutex, pdMS_TO_TICKS(1)) == pdTRUE) {
            throttle = systemState.control.throttle;
            rollCmd = systemState.control.rollCmd;
            pitchCmd = systemState.control.pitchCmd;
            yawCmd = systemState.control.yawCmd;
            armed = systemState.control.armed;
            xSemaphoreGive(controlDataMutex);
        }
        
        // 모터 믹싱
        uint16_t motor1, motor2, motor3, motor4;
        if (armed) {
            motorMixer.mix(throttle, rollCmd, pitchCmd, yawCmd, 
                          motor1, motor2, motor3, motor4);
        } else {
            motor1 = motor2 = motor3 = motor4 = 1000;  // 정지
        }
        
        // 모터 출력
        motorMixer.output(motor1, motor2, motor3, motor4);
        
        // 상태 업데이트
        systemState.motors.motor1 = motor1;
        systemState.motors.motor2 = motor2;
        systemState.motors.motor3 = motor3;
        systemState.motors.motor4 = motor4;
        systemState.motors.enabled = armed;
        
        vTaskDelayUntil(&xLastWakeTime, xFrequency);
    }
}

// 텔레메트리 및 통신 태스크 (낮은 우선순위, 코어 1)
void telemetryTask(void *parameter) {
    Serial.println("📡 텔레메트리 태스크 시작 (코어 1)");
    
    TickType_t xLastWakeTime = xTaskGetTickCount();
    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / TELEMETRY_RATE_HZ);
    
    while (true) {
        // 텔레메트리 데이터 전송
        telemetry.sendAttitude(systemState.attitude.roll, 
                             systemState.attitude.pitch, 
                             systemState.attitude.yaw);
        
        telemetry.sendBatteryStatus(systemState.system.batteryVoltage,
                                  systemState.system.batteryCurrent);
        
        telemetry.sendSystemStatus(systemState.system.loopFrequency,
                                 ESP.getFreeHeap());
        
        // 웹 인터페이스 업데이트
        webInterface.updateData(systemState);
        
        vTaskDelayUntil(&xLastWakeTime, xFrequency);
    }
}

// 안전 및 모니터링 태스크 (중간 우선순위, 코어 1)
void safetyTask(void *parameter) {
    Serial.println("🛡️  안전 태스크 시작 (코어 1)");
    
    while (true) {
        // 배터리 모니터링
        systemState.system.batteryVoltage = batteryMonitor.getVoltage();
        systemState.system.batteryCurrent = batteryMonitor.getCurrent();
        
        // 배터리 알람
        if (systemState.system.batteryVoltage < CRITICAL_BATTERY_VOLTAGE) {
            // 긴급 착륙 모드
            handleCriticalBattery();
        } else if (systemState.system.batteryVoltage < LOW_BATTERY_VOLTAGE) {
            // 저전압 경고음
            batteryMonitor.playLowVoltageAlarm();
        }
        
        // Failsafe 시스템 체크
        failsafe.update();
        
        // 시스템 헬스 체크
        checkSystemHealth();
        
        vTaskDelay(pdMS_TO_TICKS(100));  // 10Hz
    }
}

// 헬퍼 함수들
void printStartupBanner() {
    Serial.println("\n" + String("=").repeat(60));
    Serial.println("🚁 " + String(DRONE_NAME));
    Serial.println("📦 펌웨어 버전: " + String(FIRMWARE_VERSION));
    Serial.println("🏗️  빌드: " + String(BUILD_DATE));
    Serial.println("💻 플랫폼: ESP32 Arduino + PlatformIO");
    Serial.println("=".repeat(60));
}

void initializePins() {
    // LED 핀
    pinMode(LED_STATUS_PIN, OUTPUT);
    pinMode(LED_ARM_PIN, OUTPUT);
    
    // 부저
    pinMode(BUZZER_PIN, OUTPUT);
    
    // 배터리 모니터링
    pinMode(BATTERY_VOLTAGE_PIN, INPUT);
    
    Serial.println("✅ GPIO 핀 초기화 완료");
}

bool initializeHardware() {
    Serial.println("🔧 하드웨어 초기화 중...");
    
    // IMU 초기화
    if (!imu.init()) {
        Serial.println("❌ IMU 센서 초기화 실패");
        return false;
    }
    Serial.println("✅ IMU 센서 초기화 완료");
    
    // 센서 융합 시스템 초기화
    sensorFusion.init();
    Serial.println("✅ 센서 융합 시스템 초기화 완료");
    
    // PID 컨트롤러 초기화
    pidController.init();
    Serial.println("✅ PID 컨트롤러 초기화 완료");
    
    // 모터 믹서 초기화
    if (!motorMixer.init()) {
        Serial.println("❌ 모터 시스템 초기화 실패");
        return false;
    }
    Serial.println("✅ 모터 시스템 초기화 완료");
    
    // 수신기 초기화
    if (!receiver.init()) {
        Serial.println("❌ 수신기 초기화 실패");
        return false;
    }
    Serial.println("✅ 수신기 초기화 완료");
    
    // 텔레메트리 초기화
    telemetry.init();
    Serial.println("✅ 텔레메트리 시스템 초기화 완료");
    
    // 웹 인터페이스 초기화
    webInterface.init();
    Serial.println("✅ 웹 인터페이스 초기화 완료");
    
    // 안전 시스템 초기화
    failsafe.init();
    batteryMonitor.init();
    Serial.println("✅ 안전 시스템 초기화 완료");
    
    return true;
}

void createSyncObjects() {
    sensorDataMutex = xSemaphoreCreateMutex();
    controlDataMutex = xSemaphoreCreateMutex();
    
    if (sensorDataMutex == NULL || controlDataMutex == NULL) {
        Serial.println("❌ 뮤텍스 생성 실패!");
        while (1) delay(1000);
    }
    
    Serial.println("✅ FreeRTOS 동기화 객체 생성 완료");
}

void createTasks() {
    BaseType_t result;
    
    // 센서 태스크 (최고 우선순위, 코어 0)
    result = xTaskCreatePinnedToCore(
        sensorTask,
        "SensorTask",
        8192,                           // 8KB 스택
        NULL,
        configMAX_PRIORITIES - 1,       // 최고 우선순위
        &sensorTaskHandle,
        0                               // 코어 0
    );
    if (result != pdPASS) {
        Serial.println("❌ 센서 태스크 생성 실패!");
        return;
    }
    
    // 제어 태스크 (높은 우선순위, 코어 0)
    result = xTaskCreatePinnedToCore(
        controlTask,
        "ControlTask",
        6144,                           // 6KB 스택
        NULL,
        configMAX_PRIORITIES - 2,       // 두 번째 높은 우선순위
        &controlTaskHandle,
        0                               // 코어 0 (센서와 같은 코어)
    );
    if (result != pdPASS) {
        Serial.println("❌ 제어 태스크 생성 실패!");
        return;
    }
    
    // 모터 태스크 (높은 우선순위, 코어 1)
    result = xTaskCreatePinnedToCore(
        motorTask,
        "MotorTask",
        4096,                           // 4KB 스택
        NULL,
        configMAX_PRIORITIES - 2,       // 높은 우선순위
        &motorTaskHandle,
        1                               // 코어 1
    );
    if (result != pdPASS) {
        Serial.println("❌ 모터 태스크 생성 실패!");
        return;
    }
    
    // 텔레메트리 태스크 (중간 우선순위, 코어 1)
    result = xTaskCreatePinnedToCore(
        telemetryTask,
        "TelemetryTask",
        6144,                           // 6KB 스택 (웹 통신용)
        NULL,
        2,                              // 중간 우선순위
        &telemetryTaskHandle,
        1                               // 코어 1
    );
    if (result != pdPASS) {
        Serial.println("❌ 텔레메트리 태스크 생성 실패!");
        return;
    }
    
    // 안전 태스크 (낮은 우선순위, 코어 1)
    result = xTaskCreatePinnedToCore(
        safetyTask,
        "SafetyTask",
        3072,                           // 3KB 스택
        NULL,
        1,                              // 낮은 우선순위
        &safetyTaskHandle,
        1                               // 코어 1
    );
    if (result != pdPASS) {
        Serial.println("❌ 안전 태스크 생성 실패!");
        return;
    }
    
    Serial.println("✅ 모든 FreeRTOS 태스크 생성 완료");
    
    // 태스크 생성 후 메모리 상태 출력
    Serial.printf("📊 태스크 생성 후 여유 메모리: %d bytes\n", ESP.getFreeHeap());
}

void performSafetyCheck() {
    Serial.println("\n🔍 시스템 안전 점검 중...");
    
    bool safetyOK = true;
    
    // IMU 상태 체크
    if (!systemState.system.imuHealthy) {
        Serial.println("❌ IMU 센서 불안정");
        safetyOK = false;
    } else {
        Serial.println("✅ IMU 센서 정상");
    }
    
    // 배터리 전압 체크
    float voltage = batteryMonitor.getVoltage();
    if (voltage < LOW_BATTERY_VOLTAGE) {
        Serial.printf("❌ 배터리 전압 부족: %.2fV\n", voltage);
        safetyOK = false;
    } else {
        Serial.printf("✅ 배터리 전압 정상: %.2fV\n", voltage);
    }
    
    // 수신기 연결 체크 (5초 대기)
    Serial.println("📡 수신기 연결 확인 중... (5초 대기)");
    unsigned long startTime = millis();
    bool rcDetected = false;
    
    while (millis() - startTime < 5000) {
        receiver.update();
        if (receiver.isConnected()) {
            rcDetected = true;
            break;
        }
        delay(100);
    }
    
    if (!rcDetected) {
        Serial.println("⚠️  수신기 신호 없음 (테스트 모드에서 계속 진행)");
    } else {
        Serial.println("✅ 수신기 연결 정상");
    }
    
    // 메모리 체크
    uint32_t freeHeap = ESP.getFreeHeap();
    if (freeHeap < 80000) {  // 80KB 미만 시 경고
        Serial.printf("⚠️  여유 메모리 부족: %d bytes\n", freeHeap);
    } else {
        Serial.printf("✅ 메모리 상태 양호: %d bytes\n", freeHeap);
    }
    
    if (safetyOK) {
        Serial.println("✅ 모든 안전 점검 통과!");
        // 성공 신호음
        playStartupTone();
    } else {
        Serial.println("⚠️  일부 안전 점검 실패 - 주의하여 사용하세요");
        // 경고 신호음
        playWarningTone();
    }
    
    Serial.println("=".repeat(60) + "\n");
}

void printSystemStatus() {
    Serial.println("\n📊 시스템 상태 리포트");
    Serial.println("-".repeat(50));
    
    // 센서 상태
    Serial.printf("IMU 주파수: %d Hz\n", systemState.system.loopFrequency);
    Serial.printf("자세: R=%.1f° P=%.1f° Y=%.1f°\n", 
                 systemState.attitude.roll, 
                 systemState.attitude.pitch, 
                 systemState.attitude.yaw);
    
    // 제어 상태
    Serial.printf("ARM 상태: %s\n", systemState.control.armed ? "ARMED" : "DISARMED");
    Serial.printf("비행모드: %d\n", systemState.control.flightMode);
    Serial.printf("스로틀: %.2f\n", systemState.control.throttle);
    
    // 모터 상태
    Serial.printf("모터: M1=%d M2=%d M3=%d M4=%d\n",
                 systemState.motors.motor1, systemState.motors.motor2,
                 systemState.motors.motor3, systemState.motors.motor4);
    
    // 시스템 상태
    Serial.printf("배터리: %.2fV\n", systemState.system.batteryVoltage);
    Serial.printf("RC연결: %s\n", systemState.system.rcConnected ? "OK" : "FAIL");
    Serial.printf("메모리: %d bytes\n", ESP.getFreeHeap());
    Serial.printf("가동시간: %lu초\n", millis() / 1000);
    
    Serial.println("-".repeat(50) + "\n");
}

void handleEmergency() {
    Serial.println("🚨 비상 상황 발생!");
    
    // 모든 모터 즉시 정지
    systemState.control.armed = false;
    systemState.control.throttle = 0.0f;
    
    // 경고음 재생
    playEmergencyTone();
    
    // LED 점멸
    for (int i = 0; i < 10; i++) {
        digitalWrite(LED_STATUS_PIN, HIGH);
        digitalWrite(LED_ARM_PIN, HIGH);
        delay(100);
        digitalWrite(LED_STATUS_PIN, LOW);
        digitalWrite(LED_ARM_PIN, LOW);
        delay(100);
    }
}

void handleCriticalBattery() {
    Serial.println("🪫 배터리 위험 수준 - 긴급 착륙!");
    
    // 서서히 스로틀 감소하여 부드럽게 착륙
    if (systemState.control.armed) {
        float currentThrottle = systemState.control.throttle;
        if (currentThrottle > 0.3f) {
            systemState.control.throttle = currentThrottle * 0.95f;  // 5%씩 감소
        }
    }
    
    // 배터리 위험 신호음
    playCriticalBatteryTone();
}

void checkSystemHealth() {
    // 태스크 상태 체크
    if (sensorTaskHandle != NULL) {
        eTaskState state = eTaskGetState(sensorTaskHandle);
        if (state == eSuspended || state == eDeleted) {
            Serial.println("❌ 센서 태스크 비정상!");
        }
    }
    
    if (controlTaskHandle != NULL) {
        eTaskState state = eTaskGetState(controlTaskHandle);
        if (state == eSuspended || state == eDeleted) {
            Serial.println("❌ 제어 태스크 비정상!");
        }
    }
    
    // 스택 오버플로우 체크
    UBaseType_t highWaterMark = uxTaskGetStackHighWaterMark(sensorTaskHandle);
    if (highWaterMark < 512) {  // 512 bytes 미만 남음
        Serial.printf("⚠️  센서 태스크 스택 부족: %d bytes 남음\n", highWaterMark);
    }
}

void blinkErrorPattern() {
    // SOS 패턴으로 에러 표시
    // 짧은 깜빡임 3번 (S)
    for (int i = 0; i < 3; i++) {
        digitalWrite(LED_STATUS_PIN, HIGH);
        delay(200);
        digitalWrite(LED_STATUS_PIN, LOW);
        delay(200);
    }
    
    delay(500);
    
    // 긴 깜빡임 3번 (O)
    for (int i = 0; i < 3; i++) {
        digitalWrite(LED_STATUS_PIN, HIGH);
        delay(600);
        digitalWrite(LED_STATUS_PIN, LOW);
        delay(200);
    }
    
    delay(500);
    
    // 짧은 깜빡임 3번 (S)
    for (int i = 0; i < 3; i++) {
        digitalWrite(LED_STATUS_PIN, HIGH);
        delay(200);
        digitalWrite(LED_STATUS_PIN, LOW);
        delay(200);
    }
}

// 신호음 함수들
void playStartupTone() {
    // 시작 성공 멜로디
    int melody[] = {262, 330, 392, 523};  // C, E, G, C (높은음)
    int duration[] = {200, 200, 200, 400};
    
    for (int i = 0; i < 4; i++) {
        tone(BUZZER_PIN, melody[i], duration[i]);
        delay(duration[i] + 50);
    }
    noTone(BUZZER_PIN);
}

void playWarningTone() {
    // 경고음 (두 번의 비프음)
    for (int i = 0; i < 2; i++) {
        tone(BUZZER_PIN, 800, 300);
        delay(400);
    }
    noTone(BUZZER_PIN);
}

void playEmergencyTone() {
    // 긴급 상황 사이렌
    for (int i = 0; i < 5; i++) {
        tone(BUZZER_PIN, 1000, 200);
        delay(100);
        tone(BUZZER_PIN, 500, 200);
        delay(100);
    }
    noTone(BUZZER_PIN);
}

void playCriticalBatteryTone() {
    // 배터리 위험 경고음
    tone(BUZZER_PIN, 400, 1000);  // 낮고 긴 경고음
    delay(1100);
    noTone(BUZZER_PIN);
}
```

---

## 🎯 7️⃣ 다음 단계 로드맵

### **7.1 Phase 5: PID 제어 시스템 구현 (1-2주)**

#### **우선순위 1: PID 컨트롤러 클래스 구현**
```cpp
// include/control/pid_controller.h 구현 예시
class PIDController {
private:
    struct PIDGains {
        float kp, ki, kd;
        float integral;
        float prevError;
        float integralLimit;
    };
    
    PIDGains rollRate, pitchRate, yawRate;
    PIDGains rollAngle, pitchAngle;
    
public:
    void init();
    void setRateGains(float p, float i, float d, int axis);
    void setAngleGains(float p, float i, float d, int axis);
    float calculateRateControl(float setpoint, float measured, int axis);
    float calculateAngleControl(float angleSetpoint, float currentAngle, float currentRate);
    void reset();
};
```

#### **우선순위 2: 모터 믹싱 시스템**
```cpp
// include/control/motor_mixer.h 구현 예시  
class MotorMixer {
private:
    uint16_t minPulse = 1000;
    uint16_t maxPulse = 2000;
    
public:
    bool init();
    void mix(float throttle, float roll, float pitch, float yaw,
             uint16_t& motor1, uint16_t& motor2, uint16_t& motor3, uint16_t& motor4);
    void output(uint16_t m1, uint16_t m2, uint16_t m3, uint16_t m4);
    void setLimits(uint16_t min, uint16_t max);
};
```

### **7.2 Phase 6: 수신기 및 통신 시스템 (1-2주)**

#### **SBUS/PPM 수신기 인터페이스**
```cpp
// include/communication/receiver.h
class Receiver {
private:
    float channels[8];
    bool connected = false;
    unsigned long lastUpdate = 0;
    
public:
    bool init();
    void update();
    bool isConnected();
    float getThrottle();    // 채널 1
    float getRoll();        // 채널 2  
    float getPitch();       // 채널 3
    float getYaw();         // 채널 4
    bool getArmSwitch();    // 채널 5
    uint8_t getFlightModeSwitch();  // 채널 6
};
```

### **7.3 Phase 7: 실제 하드웨어 테스트 (2-3주)**

#### **단계적 테스트 계획**
1. **벤치 테스트**: 프로펠러 없이 모터 응답 확인
2. **로프 테스트**: 안전 로프 연결하여 실제 추력 테스트  
3. **첫 호버링**: 수동 조작으로 짧은 호버링
4. **PID 튜닝**: 실제 비행 데이터로 파라미터 최적화
5. **고급 비행**: 다양한 비행 모드 테스트

### **7.4 Phase 8: 고급 기능 추가 (3-4주)**

#### **추가 기능 개발 순서**
1. **고도 유지 모드** (기압 센서 추가)
2. **GPS 위치 유지** (GPS 모듈 추가)  
3. **자동 복귀 기능** (RTL - Return to Launch)
4. **웨이포인트 비행** (자율 비행)
5. **FPV 카메라 통합** (Walksnail Avatar 연동)

---

## 🛠️ 8️⃣ 개발 환경 최적화

### **8.1 VS Code 워크스페이스 설정**

#### **.vscode/settings.json**
```json
{
    "C_Cpp.intelliSenseEngine": "Default",
    "C_Cpp.default.defines": [
        "ARDUINO=183",
        "ARDUINO_ARCH_ESP32",
        "ESP32",
        "ARDUINO_NANO_ESP32"
    ],
    "C_Cpp.default.includePath": [
        "${workspaceFolder}/include",
        "${workspaceFolder}/src",
        "${workspaceFolder}/.pio/libdeps/arduino_nano_esp32_drone/*/src",
        "${workspaceFolder}/.pio/libdeps/arduino_nano_esp32_drone/*/include"
    ],
    "files.associations": {
        "*.ino": "cpp",
        "*.h": "cpp",
        "*.hpp": "cpp"
    },
    "editor.tabSize": 4,
    "editor.insertSpaces": true,
    "files.exclude": {
        ".pio": true,
        ".vscode/.browse.c_cpp.db*": true
    },
    "terminal.integrated.env.windows": {
        "PATH": "${env:PATH};${workspaceFolder}\\.pio\\build\\arduino_nano_esp32_drone"
    }
}
```

#### **.vscode/tasks.json**
```json
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "PIO: Build",
            "type": "shell",
            "command": "platformio",
            "args": ["run"],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "presentation": {
                "echo": true,
                "reveal": "always",
                "focus": false,
                "panel": "shared"
            },
            "problemMatcher": "$gcc"
        },
        {
            "label": "PIO: Upload",
            "type": "shell",
            "command": "platformio",
            "args": ["run", "--target", "upload"],
            "group": "build",
            "dependsOn": "PIO: Build"
        },
        {
            "label": "PIO: Clean",
            "type": "shell",
            "command": "platformio",
            "args": ["run", "--target", "clean"]
        },
        {
            "label": "PIO: Test",
            "type": "shell",
            "command": "platformio",
            "args": ["test"],
            "group": "test"
        },
        {
            "label": "PIO: Monitor",
            "type": "shell",
            "command": "platformio",
            "args": ["device", "monitor", "--baud", "115200"],
            "group": "build"
        }
    ]
}
```

### **8.2 Git 버전 관리 설정**

#### **.gitignore**
```gitignore
# PlatformIO
.pio
.vscode/.browse.c_cpp.db*
.vscode/c_cpp_properties.json
.vscode/launch.json

# 임시 파일
*.tmp
*.log
*.bak

# 개인 설정
secrets.h
wifi_config.h

# 빌드 결과물
*.bin
*.elf
*.map

# 운영체제
.DS_Store
Thumbs.db
```

---

## 📚 9️⃣ 학습 리소스 및 참고 자료

### **9.1 필수 학습 자료**
1. **PID 제어 이론**: Brett Beauregard의 PID 튜토리얼
2. **쿼드콥터 동역학**: MIT OpenCourseWare - Controls
3. **ESP32 FreeRTOS**: Espressif 공식 문서
4. **드론 개발**: ArduPilot/Betaflight 소스 코드 분석

### **9.2 유용한 도구들**
1. **Betaflight Configurator**: PID 튜닝 참고용
2. **Mission Planner**: 텔레메트리 분석
3. **QGroundControl**: 실시간 모니터링
4. **Logic Analyzer**: 신호 분석 (PPM/SBUS)

---

## 🎯 완료 체크리스트

### **현재 완료된 것들** ✅
```
□ VS Code + PlatformIO 개발 환경 구축
□ Arduino Nano ESP32 기본 동작 확인
□ MPU9250 센서 연결 및 데이터 읽기
□ 고급 자세 추정 시스템 (상보필터/칼만필터)
□ 실시간 웹 모니터링 시스템
□ 멀티코어 최적화 (1000Hz 센서 루프)
□ 완전한 프로젝트 템플릿 구조
```

### **다음에 해야 할 일들** 🎯
```
□ PID 컨트롤러 클래스 구현
□ 모터 믹싱 시스템 구현  
□ DShot 프로토콜 모터 제어
□ SBUS/PPM 수신기 인터페이스
□ 비행 모드 시스템 (Stabilize/Acro)
□ 안전 시스템 (Failsafe/Battery Monitor)
□ 실제 하드웨어 조립 및 테스트
□ PID 파라미터 튜닝
□ 첫 호버링 테스트
```

**축하합니다! 🎉 이제 완벽한 드론 개발 프로젝트 템플릿이 준비되었습니다. 다음 단계인 PID 제어 시스템 개발로 진행할 준비가 완료되었습니다!**