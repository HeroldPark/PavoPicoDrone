# 🚀 Arduino Nano ESP32 드론 개발 완전 로드맵

## 🎯 목표: 10-12분 비행 DIY 드론 완성

**전체 개발 기간**: 12-16주  
**구매한 키트**: Arduino Nano ESP32 + MPU9250 + SunFounder ESP32 Starter Kit

---

## 🗓️ Phase 1: 기초 하드웨어 검증 (1-2주)

### Week 1: 환경 설정 및 기본 테스트

#### **1.1 개발 환경 구축**
```bash
개발 도구 설치:
✅ ESP32 보드 패키지 (2.0.14+)
✅ Git (버전 관리)
✅ VS Code + PlatformIO + Arduino 확장 (옵션)

필수 라이브러리:
• MPU9250 by hideakitai
• ESP32Servo
• ArduinoJson
• AsyncTCP
• ESPAsyncWebServer
• PID by Brett Beauregard
```

#### **1.2 하드웨어 연결 테스트**
```cpp
테스트 항목:
✅ Arduino Nano ESP32 부팅 테스트
✅ LED 점멸 (내장 LED)
✅ 시리얼 통신 확인
✅ WiFi 연결 테스트
✅ 전력 소비 측정 (멀티미터 사용)

사용할 SunFounder 키트 부품:
• 브레드보드
• 점퍼 와이어
• LED
• 저항
• 멀티미터
```

#### **1.3 MPU9250 센서 테스트**
```cpp
// 기본 연결 테스트 코드
#include "MPU9250.h"

MPU9250 mpu;

void setup() {
    Serial.begin(115200);
    Wire.begin();
    
    if (mpu.setup(0x68)) {
        Serial.println("MPU9250 연결 성공!");
    } else {
        Serial.println("MPU9250 연결 실패!");
    }
}

void loop() {
    if (mpu.update()) {
        Serial.print("Accel: ");
        Serial.print(mpu.getAccX()); Serial.print(", ");
        Serial.print(mpu.getAccY()); Serial.print(", ");
        Serial.println(mpu.getAccZ());
        
        Serial.print("Gyro: ");
        Serial.print(mpu.getGyroX()); Serial.print(", ");
        Serial.print(mpu.getGyroY()); Serial.print(", ");
        Serial.println(mpu.getGyroZ());
    }
    delay(100);
}
```

### Week 2: 센서 데이터 수집 및 분석

#### **2.1 센서 캘리브레이션**
```cpp
개발 목표:
✅ 가속도계 오프셋 캘리브레이션
✅ 자이로스코프 드리프트 보정
✅ 자력계 하드/소프트 아이언 캘리브레이션
✅ 온도 보상 알고리즘

사용할 키트 부품:
• OLED 디스플레이 (실시간 데이터 표시)
• 버튼 (캘리브레이션 시작/중지)
• 포텐셔미터 (파라미터 조정)
```

#### **2.2 실시간 데이터 모니터링 시스템**
```cpp
기능 구현:
✅ 웹 서버 구축 (ESP32 AP 모드)
✅ 실시간 센서 데이터 스트리밍
✅ 3D 자세 시각화 (웹 기반)
✅ 데이터 로깅 (SD카드 또는 SPIFFS)

웹 인터페이스 기능:
• 실시간 그래프 (Chart.js)
• 센서 상태 모니터링
• 캘리브레이션 제어 패널
```

---

## 🧠 Phase 2: 자세 추정 알고리즘 (3-4주)

### Week 3: 기본 필터링 구현

#### **3.1 저역 통과 필터**
```cpp
class LowPassFilter {
private:
    float alpha;
    float prev_output;
    
public:
    LowPassFilter(float cutoff_freq, float dt) {
        float RC = 1.0 / (2.0 * PI * cutoff_freq);
        alpha = dt / (dt + RC);
        prev_output = 0.0;
    }
    
    float update(float input) {
        prev_output = alpha * input + (1.0 - alpha) * prev_output;
        return prev_output;
    }
};

구현 항목:
✅ 가속도계 노이즈 필터링 (20Hz 컷오프)
✅ 자이로스코프 고주파 노이즈 제거
✅ 필터 파라미터 실시간 조정
```

#### **3.2 상보 필터 구현**
```cpp
class ComplementaryFilter {
private:
    float alpha;
    float roll, pitch, yaw;
    float dt;
    
public:
    void update(float acc_x, float acc_y, float acc_z,
                float gyro_x, float gyro_y, float gyro_z) {
        
        // 가속도계로부터 각도 계산
        float acc_roll = atan2(acc_y, acc_z);
        float acc_pitch = atan2(-acc_x, sqrt(acc_y*acc_y + acc_z*acc_z));
        
        // 자이로스코프 적분
        roll += gyro_x * dt;
        pitch += gyro_y * dt;
        yaw += gyro_z * dt;
        
        // 상보 필터 적용
        roll = alpha * roll + (1.0 - alpha) * acc_roll;
        pitch = alpha * pitch + (1.0 - alpha) * acc_pitch;
    }
};
```

### Week 4: 고급 자세 추정

#### **4.1 쿼터니언 기반 자세 추정**
```cpp
class QuaternionFilter {
private:
    float q0, q1, q2, q3;  // 쿼터니언 요소
    float beta;            // 필터 게인
    
public:
    void madgwickUpdate(float gx, float gy, float gz,
                       float ax, float ay, float az,
                       float mx, float my, float mz);
    
    void getRollPitchYaw(float& roll, float& pitch, float& yaw);
};

구현 목표:
✅ Madgwick AHRS 알고리즘 구현
✅ 자력계 데이터 퓨전
✅ 김벌락 방지
✅ 드리프트 최소화 (±1도 이내)
```

#### **4.2 칼만 필터 (선택사항)**
```cpp
고급 기능:
✅ 확장 칼만 필터 구현
✅ 센서 노이즈 모델링
✅ 동적 환경 적응
✅ 예측-보정 사이클 최적화
```

---

## 🎮 Phase 3: 제어 시스템 개발 (5-7주)

### Week 5: PID 컨트롤러 기초

#### **5.1 Single-axis PID 구현**
```cpp
class PIDController {
private:
    float kp, ki, kd;
    float integral, prev_error;
    float dt;
    float integral_limit;  // 적분 포화 방지
    
public:
    float update(float setpoint, float measured_value) {
        float error = setpoint - measured_value;
        
        // 비례항
        float proportional = kp * error;
        
        // 적분항 (windup 방지)
        integral += error * dt;
        integral = constrain(integral, -integral_limit, integral_limit);
        float integral_term = ki * integral;
        
        // 미분항
        float derivative = (error - prev_error) / dt;
        float derivative_term = kd * derivative;
        
        prev_error = error;
        
        return proportional + integral_term + derivative_term;
    }
};

테스트 방법:
• 서보모터로 각도 제어 테스트
• 스텝 응답 측정
• 오버슈트, 정착시간 분석
```

#### **5.2 3-axis 자세 제어**
```cpp
구현 기능:
✅ Roll PID 컨트롤러
✅ Pitch PID 컨트롤러  
✅ Yaw PID 컨트롤러
✅ Rate PID (각속도 제어)
✅ Angle PID (각도 제어)

사용할 키트 부품:
• 서보모터 3개 (각 축 시뮬레이션)
• 포텐셔미터 (PID 게인 조정)
• LCD 디스플레이 (PID 파라미터 표시)
```

### Week 6: 모터 제어 시스템

#### **6.1 DShot 프로토콜 구현**
```cpp
class DShot {
private:
    static const int DSHOT_FRAME_SIZE = 16;
    static const int DSHOT_DMA_BUFFER_SIZE = 18;
    
public:
    void init(int pin);
    void writeThrottle(int pin, uint16_t throttle);
    uint16_t prepareDShotPacket(uint16_t throttle);
    void sendDShotPacket(int pin, uint16_t packet);
};

구현 목표:
✅ DShot600/1200 프로토콜
✅ 체크섬 검증
✅ 텔레메트리 수신 (선택사항)
✅ 4채널 동시 출력

테스트 방법:
• 오실로스코프로 신호 검증
• 단일 ESC 연결 테스트
• 스로틀 응답 측정
```

#### **6.2 모터 믹싱 알고리즘**
```cpp
class QuadMotorMixer {
public:
    struct MotorOutput {
        float motor1, motor2, motor3, motor4;
    };
    
    MotorOutput mix(float throttle, float roll, float pitch, float yaw) {
        MotorOutput output;
        
        // X 구성 쿼드콥터 믹싱
        output.motor1 = throttle - roll - pitch + yaw;  // 전방 우측
        output.motor2 = throttle + roll - pitch - yaw;  // 전방 좌측  
        output.motor3 = throttle + roll + pitch + yaw;  // 후방 좌측
        output.motor4 = throttle - roll + pitch - yaw;  // 후방 우측
        
        // 출력 제한
        output.motor1 = constrain(output.motor1, 0, 1000);
        output.motor2 = constrain(output.motor2, 0, 1000);
        output.motor3 = constrain(output.motor3, 0, 1000);
        output.motor4 = constrain(output.motor4, 0, 1000);
        
        return output;
    }
};
```

### Week 7: 비행 모드 구현

#### **7.1 비행 모드 시스템**
```cpp
enum FlightMode {
    DISARMED,
    STABILIZE,  // 자세 안정화
    ACRO,       // 각속도 제어
    ALTITUDE,   // 고도 유지
    POSITION    // 위치 유지
};

class FlightController {
private:
    FlightMode current_mode;
    PIDController roll_rate_pid, pitch_rate_pid, yaw_rate_pid;
    PIDController roll_angle_pid, pitch_angle_pid, yaw_angle_pid;
    
public:
    void update();
    void setMode(FlightMode mode);
    void armMotors();
    void disarmMotors();
};
```

#### **7.2 안전 시스템**
```cpp
안전 기능 구현:
✅ Failsafe 시스템 (수신기 신호 손실)
✅ 배터리 전압 모니터링
✅ 자세 제한 (최대 각도 설정)
✅ 모터 온도 보호
✅ 크래시 감지 및 자동 디스암

사용할 키트 부품:
• 버저 (알람)
• LED (상태 표시)
• 전압 분배기 (배터리 모니터링)
```

---

## 📡 Phase 4: 통신 시스템 (8-9주)

### Week 8: 수신기 인터페이스

#### **8.1 다중 프로토콜 지원**
```cpp
class ReceiverInterface {
public:
    virtual void init() = 0;
    virtual bool isConnected() = 0;
    virtual void getChannels(uint16_t channels[8]) = 0;
};

class PPMReceiver : public ReceiverInterface {
    // PPM 신호 디코딩
};

class SBUSReceiver : public ReceiverInterface {  
    // SBUS 프로토콜 처리
};

class CRSFReceiver : public ReceiverInterface {
    // CRSF/ELRS 프로토콜
};

구현 프로토콜:
✅ PPM (Pulse Position Modulation)
✅ SBUS (Serial Bus)
✅ CRSF (Crossfire/ExpressLRS)

테스트 방법:
• 신호 생성기로 PPM 신호 생성
• 오실로스코프로 타이밍 검증
• 채널 매핑 및 스케일링 테스트
```

#### **8.2 채널 매핑 및 스케일링**
```cpp
class ChannelMapper {
private:
    struct ChannelConfig {
        uint16_t min_pulse;
        uint16_t max_pulse; 
        uint16_t center_pulse;
        bool reversed;
    };
    
    ChannelConfig channels[8];
    
public:
    float getThrottle();
    float getRoll();
    float getPitch(); 
    float getYaw();
    bool getArmSwitch();
    int getFlightMode();
};
```

### Week 9: 텔레메트리 및 OSD

#### **9.1 MAVLink 프로토콜**
```cpp
#include <mavlink.h>

class MAVLinkTelemetry {
public:
    void sendHeartbeat();
    void sendAttitude(float roll, float pitch, float yaw);
    void sendBatteryStatus(float voltage, float current);
    void sendGPSPosition(float lat, float lon, float alt);
    
private:
    void sendMAVLinkMessage(mavlink_message_t& msg);
};

기능 구현:
✅ 실시간 텔레메트리 전송
✅ Mission Planner 호환
✅ 파라미터 원격 조정
✅ 로그 다운로드
```

#### **9.2 웹 기반 GCS (Ground Control Station)**
```html
<!-- 실시간 모니터링 인터페이스 -->
<!DOCTYPE html>
<html>
<head>
    <title>드론 제어 시스템</title>
    <script src="chart.js"></script>
</head>
<body>
    <div id="attitude-display">
        <!-- 3D 자세 표시 -->
    </div>
    
    <div id="telemetry-data">
        <!-- 실시간 데이터 -->
    </div>
    
    <div id="pid-tuning">
        <!-- PID 게인 조정 -->
    </div>
    
    <script>
        // WebSocket 연결
        var ws = new WebSocket('ws://192.168.1.1:81');
        
        ws.onmessage = function(event) {
            var data = JSON.parse(event.data);
            updateDisplay(data);
        };
    </script>
</body>
</html>
```

---

## 🎥 Phase 5: HD 비디오 시스템 (10-11주)

### Week 10: Walksnail Avatar 연동

#### **10.1 UART 통신 인터페이스**
```cpp
class WalksnailInterface {
private:
    HardwareSerial* uart_port;
    
public:
    void init(HardwareSerial* port);
    void sendOSDData(float voltage, int satellite_count, 
                    float altitude, int flight_mode);
    void setRecordingMode(bool enable);
    void adjustCameraSettings(int brightness, int contrast);
};

기능 구현:
✅ OSD 데이터 오버레이
✅ 녹화 제어 (자동/수동)
✅ 카메라 설정 원격 조정
✅ 비디오 품질 최적화
```

#### **10.2 HD 촬영 최적화**
```cpp
성능 최적화:
✅ 진동 댐핑 알고리즘
✅ 짐벌 제어 (선택사항)
✅ 자동 노출 제어 연동
✅ ND 필터 자동 전환

촬영 모드:
• 시네마틱 모드 (부드러운 움직임)
• 스포츠 모드 (빠른 반응)
• 매뉴얼 모드 (완전 수동 제어)
```

---

## 🔧 Phase 6: 시스템 통합 및 최적화 (12-16주)

### Week 11-12: 전체 시스템 통합

#### **12.1 메인 펌웨어 아키텍처**
```cpp
// main.cpp - 메인 루프 구조
#include "flight_controller.h"
#include "sensor_manager.h" 
#include "receiver_interface.h"
#include "telemetry_system.h"

FlightController fc;
SensorManager sensors;
ReceiverInterface* receiver;
TelemetrySystem telemetry;

void setup() {
    // 하드웨어 초기화
    sensors.init();
    receiver->init();
    telemetry.init();
    fc.init();
    
    Serial.println("드론 시스템 초기화 완료!");
}

void loop() {
    static uint32_t loop_timer = micros();
    
    // 센서 데이터 읽기 (1kHz)
    sensors.update();
    
    // 수신기 데이터 처리
    receiver->update();
    
    // 비행 제어 계산
    fc.update(sensors.getIMU(), receiver->getChannels());
    
    // 텔레메트리 전송 (50Hz)
    if (micros() - telemetry_timer > 20000) {
        telemetry.update();
        telemetry_timer = micros();
    }
    
    // 정확한 루프 타이밍 유지
    while (micros() - loop_timer < 1000) {}
    loop_timer = micros();
}
```

#### **12.2 성능 최적화**
```cpp
최적화 항목:
✅ 메모리 사용량 최적화 (80% 이하 유지)
✅ CPU 사용률 모니터링 (95% 이하)
✅ 루프 타이밍 최적화 (1ms ±10μs)
✅ 전력 소비 최적화 (목표: 10시간 대기 모드)

성능 모니터링:
• 실시간 성능 지표 표시
• 메모리 누수 감지
• 스택 오버플로우 방지
• Watchdog 타이머 구현
```

### Week 13-14: 지상 테스트 및 튜닝

#### **14.1 벤치 테스트**
```cpp
테스트 시나리오:
✅ 센서 정확도 테스트 (±1도 이내)
✅ PID 응답 테스트 (오버슈트 5% 이하)
✅ 모터 동기화 테스트 (±1% 이내)
✅ 배터리 수명 테스트 (목표: 12분)
✅ 온도 스트레스 테스트 (-10°C ~ 60°C)

사용할 키트 부품:
• 온습도 센서 (환경 모니터링)
• 실시간 클록 (정확한 시간 측정)
• SD카드 모듈 (테스트 데이터 로깅)
```

#### **14.2 자동 튜닝 시스템**
```cpp
class AutoTune {
private:
    enum TuneState {
        IDLE,
        MEASURING,
        CALCULATING,
        APPLYING
    };
    
    TuneState state;
    
public:
    void startAutoTune(int axis);
    void processStep();
    bool isComplete();
    void getPIDGains(float& p, float& i, float& d);
};

구현 기능:
✅ 자동 PID 튜닝 (Relay/Ziegler-Nichols)
✅ 진동 분석 기반 필터 설정
✅ 모터 개별 보정
✅ 배터리별 성능 프로파일 저장
```

### Week 15-16: 최종 검증 및 문서화

#### **16.1 최종 시스템 검증**
```cpp
검증 체크리스트:
□ 모든 센서 정상 동작
□ 제어 응답 시간 < 10ms  
□ 자세 추정 오차 < 2도
□ 배터리 수명 > 10분
□ 비상 상황 대응 정상
□ HD 영상 품질 만족
□ 원격 조종 범위 > 500m
□ 자동 복귀 기능 정상

최종 성능 목표:
• 호버링 정확도: ±10cm
• 최대 경사각: 45도
• 최대 각속도: 720deg/s
• 비행 시간: 10-12분
• HD 녹화: 1080p@60fps
```

#### **16.2 문서화 및 백업**
```
완성 문서:
📁 Hardware/
  ├── Schematic.pdf
  ├── PCB_Layout.pdf
  ├── BOM.xlsx
  └── Assembly_Guide.md

📁 Software/
  ├── src/ (전체 소스코드)
  ├── libraries/ (사용된 라이브러리)
  ├── documentation/ (API 문서)
  └── examples/ (예제 코드)

📁 Calibration/
  ├── PID_Settings.json
  ├── Sensor_Calibration.json
  └── Motor_Mapping.json

📁 Testing/
  ├── Test_Results.xlsx
  ├── Flight_Logs/
  └── Performance_Analysis.pdf
```

---

## 📊 개발 진행률 추적

### **마일스톤 체크리스트**

#### **Phase 1 완료 기준**
- [ ] Arduino Nano ESP32 정상 부팅
- [ ] MPU9250 센서 데이터 읽기 성공
- [ ] 기본 웹 서버 구동
- [ ] 실시간 센서 모니터링

#### **Phase 2 완료 기준**  
- [ ] 자세 추정 오차 < 3도
- [ ] 상보/칼만 필터 정상 동작
- [ ] 드리프트 보정 효과 확인
- [ ] 3D 자세 시각화 완료

#### **Phase 3 완료 기준**
- [ ] PID 제어 안정화 달성
- [ ] DShot 프로토콜 정상 동작  
- [ ] 모터 믹싱 알고리즘 검증
- [ ] 비행 모드 전환 정상

#### **Phase 4 완료 기준**
- [ ] 수신기 신호 정상 수신
- [ ] 텔레메트리 데이터 전송
- [ ] 웹 GCS 완전 기능
- [ ] 원격 파라미터 조정

#### **Phase 5 완료 기준**
- [ ] HD 영상 전송 안정
- [ ] OSD 데이터 오버레이
- [ ] 녹화 제어 정상
- [ ] 영상 품질 최적화

#### **Phase 6 완료 기준**
- [ ] 전체 시스템 통합
- [ ] 성능 최적화 완료
- [ ] 모든 테스트 통과
- [ ] 문서화 완료

---

## 🚨 주요 위험 요소 및 대응 방안

### **기술적 위험**
1. **센서 노이즈 과다**
   - 대응: 하드웨어 필터 + 소프트웨어 필터 조합
   
2. **실시간 성능 부족**
   - 대응: FreeRTOS 도입, 코드 최적화
   
3. **전력 소비 과다**
   - 대응: 저전력 모드 구현, 효율적인 알고리즘

### **하드웨어 위험**
1. **부품 호환성 문제**
   - 대응: 충분한 프로토타이핑, 대체 부품 확보
   
2. **진동/간섭 문제**  
   - 대응: 적절한 차폐, 배치 최적화

### **개발 일정 위험**
1. **복잡도 과소평가**
   - 대응: 단계별 개발, 우선순위 설정
   
2. **디버깅 시간 과다**
   - 대응: 충분한 로깅, 시뮬레이션 활용

---

## 🎯 성공을 위한 핵심 조언

### **개발 원칙**
1. **단계적 접근**: 한 번에 하나씩, 확실하게
2. **충분한 테스트**: 각 단계마다 철저한 검증
3. **문서화**: 모든 과정과 결과 기록
4. **백업**: 작동하는 버전 항상 보관

### **효율적인 개발**
1. **시뮬레이션 활용**: 실제 테스트 전 충분한 시뮬레이션
2. **커뮤니티 활용**: 드론 개발 커뮤니티 참여
3. **오픈소스 활용**: 검증된 라이브러리 적극 활용
4. **점진적 개선**: 완벽보다는 동작하는 것 먼저

**이 로드맵을 따라가면 성공적으로 DIY 드론을 완성할 수 있습니다! 화이팅! 🚀**